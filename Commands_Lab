# ===== INSTALLATION AND SETUP =====

## Prerequisites
# Ubuntu 22.04 LTS
# ROS 2 Humble (Desktop Full)

## 1. Install ROS 2 Humble
# Follow official instructions: https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html
sudo apt update && sudo apt install locales
sudo locale-gen en_US en_US.UTF-8
sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
export LANG=en_US.UTF-8

sudo apt install software-properties-common
sudo add-apt-repository universe
sudo apt update && sudo apt install curl -y
sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null

sudo apt update
sudo apt upgrade
sudo apt install ros-humble-desktop-full

## 2. Install ROS 2 Development Tools
sudo apt install python3-colcon-common-extensions python3-rosdep python3-vcstool

## 3. Initialize rosdep
sudo rosdep init
rosdep update

## 4. Clone this workspace
cd ~/Repos  # or your preferred location
git clone <your-repo-url> ur_ws
cd ur_ws

## 5. Install dependencies
rosdep install --from-paths src --ignore-src -r -y

## 6. Additional dependencies for UR5 and teleoperation
sudo apt install ros-humble-moveit ros-humble-ros2-control ros-humble-ros2-controllers
sudo apt install python3-pip
pip3 install flask numpy  # For HTTP server control

# For SpaceMouse support (optional)
pip3 install pyspacemouse

# For VR teleoperation (optional - requires OpenVR/SteamVR)
pip3 install openvr

## 7. Build the workspace
cd ~/Repos/ur_ws
colcon build --symlink-install

## 8. Source the workspace
source install/setup.bash

# Add to ~/.bashrc for convenience:
echo "source ~/ur5-robotiq-ros2-control/install/setup.bash" >> ~/.bashrc

## 9. Apply RViz fix (prevents crashes with snap-installed apps)
# Add to ~/.bashrc:
echo 'export LD_LIBRARY_PATH="/usr/lib/x86_64-linux-gnu:/lib/x86_64-linux-gnu:/opt/ros/humble/lib:/opt/ros/humble/opt/rviz_ogre_vendor/lib"' >> ~/.bashrc
source ~/.bashrc

## 10. Verify installation
ros2 pkg list | grep ur  # Should show ur packages
ros2 pkg list | grep robotiq  # Should show robotiq packages

# ===== BASIC USAGE COMMANDS =====

# Launch UR5 controller (simulation)
# NOTE: If running from snap-based VS Code terminal, use ./launch_ur5_nosnap.sh to avoid RViz snap library conflicts
ros2 launch ur_robot_driver ur_control.launch.py ur_type:=ur5 robot_ip:=192.168.1.102 use_fake_hardware:=true

# Launch UR5 controller (RECOMMENDED - avoids snap library conflicts)
./launch_ur5_nosnap.sh 192.168.1.102 true

# Launch MoveIt with RViz
# NOTE: If running from snap-based VS Code terminal, use ./launch_moveit_nosnap.sh to avoid RViz snap library conflicts
ros2 launch ur_moveit_config ur_moveit.launch.py ur_type:=ur5 launch_rviz:=true

# Launch MoveIt (RECOMMENDED - avoids snap library conflicts)
./launch_moveit_nosnap.sh ur5 true

# Control real robot (NOT for simulation)
#ros2 run robotiq_2f_urcap_adapter robotiq_2f_adapter_node.py --ros-args -p robot_ip:=192.168.1.102

# Run general controller with kinematics (Note: random_joint_goal is C++ executable, not .py)
ros2 run ur5_gen_controller random_joint_goal --ros-args --params-file /home/rml/ur_ws/src/Universal_Robots_ROS2_Driver/ur_moveit_config/config/kinematics.yaml

# ===== UR5 + ROBOTIQ 2F-85 GRIPPER INTEGRATION =====
# Launch UR5 with Robotiq 2F-85 gripper (RECOMMENDED - includes RViz fix)
./launch_ur5_robotiq.sh

# With real robot (replace IP as needed)
./launch_ur5_robotiq.sh 192.168.1.102 false

# Direct launch (requires RViz fix in bashrc - see RVIZ_FIX.md)
ros2 launch ur5_robotiq_description ur5_robotiq.launch.py ur_type:=ur5 use_fake_hardware:=true

# Launch with MoveIt (gripper fully integrated with collision checking)
ros2 launch ur_moveit_config ur_moveit.launch.py ur_type:=ur5 \
  description_package:=ur5_robotiq_description \
  description_file:=ur5_robotiq.urdf.xacro \
  moveit_config_package:=ur5_robotiq_description \
  moveit_config_file:=ur5_robotiq.srdf.xacro \
  use_fake_hardware:=true

# Verify gripper segments are loaded
ros2 topic echo /robot_description --once | grep robotiq

# ===== RVIZ FIX (if RViz crashes) =====
# The fix is now in ~/.bashrc, but for manual override:
export LD_LIBRARY_PATH="/usr/lib/x86_64-linux-gnu:/lib/x86_64-linux-gnu:/opt/ros/humble/lib:/opt/ros/humble/opt/rviz_ogre_vendor/lib"
source ~/Repos/ur_ws/install/setup.bash
# Then launch normally

# Test RViz without snap interference
./test_rviz_nosnap.sh


# ===== TELEOPERATION CONTROL =====
# General controller node (processes teleop commands from all sources)
ros2 run ur5_gen_controller random_joint_goal --ros-args \
  -p use_http_server:=false \
  -p use_random_motion:=false \
  -p max_iterations:=10000

# With HTTP server enabled (for Python control)
ros2 run ur5_gen_controller random_joint_goal --ros-args \
  -p use_http_server:=true \
  -p action_server_url:=http://localhost:5000/get_action \
  -p use_random_motion:=false

# With random motion for testing
ros2 run ur5_gen_controller random_joint_goal --ros-args \
  -p use_http_server:=false \
  -p use_random_motion:=true

# Keyboard teleoperation
ros2 run ur5_keyboard_teleop keyboard_teleop_node --ros-args \
  -p linear_step:=0.01 \
  -p angular_step:=0.05

# SpaceMouse teleoperation
ros2 run ur5_spacemouse_teleop spacemouse_teleop_node --ros-args \
  -p scale_translation:=0.001 \
  -p scale_rotation:=0.005 \
  -p publish_rate:=10.0

# VR teleoperation (HTC Vive)
ros2 run ur5_vr_teleop vr_teleop_node --ros-args \
  -p controller_side:=any \
  -p scale_translation:=50.0 \
  -p scale_rotation:=50.0

# VR with custom sensitivity
ros2 run ur5_vr_teleop vr_teleop_node --ros-args \
  -p scale_translation:=100.0 \
  -p scale_rotation:=100.0

# ===== HTTP ACTION SERVER =====
# Start Python HTTP server for sending pose deltas
# Server should expose GET /get_action endpoint returning:
# {"joints": {"x": 0.01, "y": 0.0, "z": 0.0, "roll": 0.0, "pitch": 0.0, "yaw": 0.0}}
# Example with Flask:
# @app.route('/get_action', methods=['GET'])
# def get_action():
#     return jsonify({"joints": {"x": dx, "y": dy, "z": dz, "roll": dr, "pitch": dp, "yaw": dyw}})

# ===== KINESTHETIC TEACHING =====
# Record and replay robot trajectories through manual guidance

# Launch complete kinesthetic teaching system (recorder + player + visualizer)
ros2 launch ur5_kinesthetic_teaching kinesthetic_teaching.launch.py

# Launch only trajectory recorder
ros2 launch ur5_kinesthetic_teaching recorder.launch.py

# Launch only trajectory player
ros2 launch ur5_kinesthetic_teaching player.launch.py

# Recording Control Services
# Start recording a new trajectory
ros2 service call /trajectory_recorder/start_recording std_srvs/srv/Trigger

# Stop recording (auto-saves if configured)
ros2 service call /trajectory_recorder/stop_recording std_srvs/srv/Trigger

# Manually save current trajectory
ros2 service call /trajectory_recorder/save_trajectory std_srvs/srv/Trigger

# Clear recorded data without saving
ros2 service call /trajectory_recorder/clear_trajectory std_srvs/srv/Trigger

# Playback Control Services
# Load most recent trajectory file
ros2 service call /trajectory_player/load_trajectory std_srvs/srv/Trigger

# Play the loaded trajectory
ros2 service call /trajectory_player/play_trajectory std_srvs/srv/Trigger

# Stop current playback
ros2 service call /trajectory_player/stop_playback std_srvs/srv/Trigger

# List available trajectory files
ros2 service call /trajectory_player/list_trajectories std_srvs/srv/Trigger

# Visualization Services
# Load and visualize latest trajectory
ros2 service call /trajectory_visualizer/load_latest std_srvs/srv/Trigger

# Clear visualization markers
ros2 service call /trajectory_visualizer/clear_visualization std_srvs/srv/Trigger

# Playback Speed Control
# Set playback speed to 0.5x (half speed)
ros2 topic pub /trajectory_player/set_playback_speed std_msgs/Float32 "data: 0.5" --once

# Set playback speed to 2.0x (double speed)
ros2 topic pub /trajectory_player/set_playback_speed std_msgs/Float32 "data: 2.0" --once

# Custom launch with parameters
ros2 launch ur5_kinesthetic_teaching kinesthetic_teaching.launch.py \
  trajectory_dir:=~/my_trajectories \
  recording_rate:=50.0 \
  end_effector_frame:=tool0

# Launch with looping playback
ros2 launch ur5_kinesthetic_teaching player.launch.py \
  loop_playback:=true \
  playback_speed:=1.5

# Post-Process Trajectories (Remove Idle Time)
# Basic usage - removes idle time with default threshold (0.001 rad)
python3 src/ur5_kinesthetic_teaching/scripts/trajectory_postprocess.py \
  ~/ur5_trajectories/trajectory_20251119_132731.json

# With verbose output - see detailed motion detection info
python3 src/ur5_kinesthetic_teaching/scripts/trajectory_postprocess.py \
  ~/ur5_trajectories/trajectory_20251119_132731.json --verbose

# Custom threshold - more sensitive (detects smaller movements)
python3 src/ur5_kinesthetic_teaching/scripts/trajectory_postprocess.py \
  ~/ur5_trajectories/my_trajectory.json --threshold 0.0005

# Custom output file
python3 src/ur5_kinesthetic_teaching/scripts/trajectory_postprocess.py \
  ~/ur5_trajectories/raw_trajectory.json \
  --output ~/ur5_trajectories/clean_trajectory.json

# Batch process all trajectories
for file in ~/ur5_trajectories/trajectory_*.json; do
    echo "Processing: $file"
    python3 src/ur5_kinesthetic_teaching/scripts/trajectory_postprocess.py \
        "$file" --threshold 0.001
done


